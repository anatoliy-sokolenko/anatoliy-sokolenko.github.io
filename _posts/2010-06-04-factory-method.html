---
title: "Как не надо синхронизировать factory method"
layout: "post"
permalink: "/2010/06/factory-method.html"
uuid: "7809878594235733395"
guid: "tag:blogger.com,1999:blog-1763451622132357586.post-7809878594235733395"
date: "2010-06-04 09:05:00"
updated: "2011-10-19 11:25:44"
description: 
blogger:
    siteid: "1763451622132357586"
    postid: "7809878594235733395"
    comments: "4"
tags: []
comments: true
share: true
categories: [trash]
---

<div class="css-full-post-content js-full-post-content">
На так давно мне рассказали о достаточно интересной методике <a href="http://www.ibm.com/developerworks/java/library/j-dcl.html">double-checked locking</a> и я естественно ринулся в бой применяя ее, буквально все синхронизированный синглтоны были заменены на двойные if. Прирост производительности оказался действительно вполне ощутим.<br /><a name='more'></a><br />И узнал я об этой технике как раз вовремя, ибо очень пригодилось. В один прекрасный момент после окончания очередного куска девелопмента наше web-приложение стало ощутимо тормозить, после прочтения трассы стека стало ясно, что большинство ajp-http потоков ожидают получения блокировки на строке 8 следующего участка кода (естественно оригинал был несколько сложнее): <br /><script src="https://gist.github.com/1298020.js?file=ServiceFactoryImpl_Buggy.java"></script>Казалось бы безопасный участок кода, ан нет, не все так просто. Строка 5 не синхронизированна и потоки могут получить к ней доступ одновременно. Внутри HashMap оперирует сразу несколькими массивами для того, что бы ускорить поиск данных. И соответственно, если исполнение метода get будет прервано, а затем возобновлено на выходе будут не верные данные или того лучше исключение, аля IndexOutOfBoundException. После чего, если потоку все таки повезло и вместо не валидных данных и исключений он получал null, тот благополучно отправлялся к собратьям на блокировку. Уж не знаю почему, но моим потокам везло.<br />Безусловно автор хотел ускорить работу метода для случая, если сервис уже инициализирован. Но делать это следует несколько окуратнее:<br /><script src="https://gist.github.com/1298020.js?file=ServiceFactoryImpl_Correct.java"></script>Как видно вызов метода get будет выполняться почти так же быстро как и без блокировки, ибо все потоки пытающиеся читать будут делать это одновременно, но если появиться поток, которому нужно вызвать put "читателям" придется обождать.<br />В свою очередь, если искомый сервис еще не существует устанавливается блокировка записи (все читатели тормозятся), проверяется не появился ли сервис пока мы блокировались, сервис создается и все потоки разблокируются.
</div>
