---
title: "Платформо-зависимые настройки"
layout: "post"
permalink: "/2010/11/blog-post.html"
uuid: "2136653079578358197"
guid: "tag:blogger.com,1999:blog-1763451622132357586.post-2136653079578358197"
date: "2010-11-27 21:42:00"
updated: "2011-10-19 12:16:11"
description: 
blogger:
    siteid: "1763451622132357586"
    postid: "2136653079578358197"
    comments: "0"
tags: [java, spring]
comments: true
categories: [blog]
---

<div class="css-full-post-content js-full-post-content">
Имеем Java web-приложение с использование Spring Framework. Стоит задача реализовать поддержку конфигурации приложения в зависимости от платформы, на которой приложение развернуто. <br /><a name='more'></a><br />Естественно, что в случае с подключением различных баз данных лучшим вариантом будет использование, встроенной в Java, технологии JNDI. Но кроме подключения к базам данных случаются и другие оказии.<br /><br />Решение достаточно тривиально — заставить Spring Framework загружать различные .properties файлы для различных окружений.<br /><script src="https://gist.github.com/1298123.js?file=gistfile1.xml"></script>Конструкция #{ systemEnvironment[ 'SUPER_APP_ENV' ] } вычитывает указанную переменную окружения.<br /><br />Собственно логика написанного достаточно проста. Предположим, что переменная окружения SUPER_APP_ENV имеет значение production. Сначала загружается application.properties, содержащий значения по-умолчанию, после этого вычитывается application-production.properties, данные из второго файлы затирают данные из первого, частично или полностью в зависимости от степени пересечения.<br /><br />Cтоит оговорить некоторые детали реализации. Конструкция #{ systemEnvironment[ '...' ] } основана на Spring EL, а следовательно поддерживается только Spring 3, вместо нее можно использовать ${ ... }. Но для меня этот вариант не работал, поскольку используемый в моем проекте Hudson в комбинации с Maven упрямо затирали указанную конструкцию текущим значением переменной. Причем параметризованная сборка в Hudson была отключена, а Maven сам по себе затирает только конструкции вида ${ env.SUPER_APP_ENV }. В общем элемент мистики присутствует.<br /><br />Следует подчеркнуть, что подобный подход будет хорошо работать только в случае, если имеется малое количество платформ развертывания и им можно полностью доверять. Типичный пример — существует только production, testing и development окружение. В случае большого количества неизвестных платформ развертывания такой подход по понятным причинам работать не будет.
</div>