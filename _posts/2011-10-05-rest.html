---
title: "Чем мне не нравится REST"
layout: "post"
permalink: "/2011/10/rest.html"
uuid: "6095342783124106002"
guid: "tag:blogger.com,1999:blog-1763451622132357586.post-6095342783124106002"
date: "2011-10-05 17:26:00"
updated: "2011-10-06 06:39:13"
description: 
blogger:
    siteid: "1763451622132357586"
    postid: "6095342783124106002"
    comments: "0"
tags: []
comments: true
share: true
categories: [trash]
---

<div class="css-full-post-content js-full-post-content">
<div style="text-align: justify;"><a href="http://2.bp.blogspot.com/-BBBO_i1RMGM/ToyaP2947uI/AAAAAAAAA-w/6gtlpnZzqHI/s1600/communication.jpg" imageanchor="1" style="clear: right; float: right; margin-bottom: 1em; margin-left: 1em;"><img border="0" height="173" src="http://2.bp.blogspot.com/-BBBO_i1RMGM/ToyaP2947uI/AAAAAAAAA-w/6gtlpnZzqHI/s200/communication.jpg" width="200" /></a>Когда я познакомился с REST подходом к построению web-сервисов мне он показался достаточно интересным. К тому же, о том, насколько крут REST говорили практически все. Более глубокое знакомство убедило меня в том, что REST создает больше проблем, чем решает. Более того REST формирует опасное ощущение разрешенности многих стандартных проблем, связанных с разработкой web-приложений.<br /><a name='more'></a>О них и пойдет речь:</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">1. <b>Отсутствие типизации</b>. REST не поддерживает ни динамической, ни статической типизации, что значительно усложняет интеграцию и тестирование этой интеграции. Нужно заботится не только о том, чтобы реальное и ожидаемое поведения систем совпадали, нужно проверять и то, что используемые модели данных поддерживаются. Теоретически спецификация <a href="http://www.ibm.com/developerworks/webservices/library/ws-restwsdl/">WSDL 2.0</a> оперирует терминами REST и могла бы быть использована для поддержки типизации в REST сервисах. Однако, кроме всеми горячо любимого Axis2 и мертворожденного <a href="http://ws.apache.org/woden/">Apache Woden</a> связка REST WSDL 2.0 никем не поддерживается.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">2. <b>Просто реализовать CRUD семантику</b>, однако реализация любой другой логики взаимодействия вызывает значительные затруднения. Мой любимый пример <span class="st">—</span> пакетные запросы, которые жизненно необходимы в любом web-приложении. Попробуйте реализовать пакетное удаление в REST. Нет Вы попробуйте! Глагол DELETE не поддерживает тела запроса. Точнее <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html">спецификация HTTP</a> не упоминает о наличии тела запроса у DELETE. Соответственно, разработчики библиотек реализовывали его поддержку по желанию. С GET ситуация еще лучше. Там тела запроса быть не может, таким образом о сложных структурированных  запросах на чтение можно забыть. Любой пакетный запрос в конечном счете превращается в POST.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">3. <b>Неполная поддержка HTTP-методов </b>(REST-глаголов) браузерами. Поскольку HTML4 и XHTML1 требовали обязательной поддержки только GET и POST большинство разработчиков браузеров и не заморачивались реализацией всех остальных методов. Соответственно, единственный гарантированный способ поддерживать другие глаголы <span class="st">—</span> добавление поля с именем глагола в POST запрос, что опять-таки нарушает логику REST.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">4. <b>Семантика глагола POST </b>требует передачи всего содержимого изменяемого объекта. На первый взгляд это упрощает реализацию, но только до того момента, как размер объектов вдруг начинает превышать 4Кб и количество операций изменения превышает 100 запросов в секунду. После этого разработчик хватается за голову и начинает реализовывать дополнительные методы частичного редактирования. Что вновь нарушает логику REST. Возможное решение проблемы полного редактирования предлагает спецификация <a href="http://tools.ietf.org/html/rfc5789">RFC5789</a> PATCH Method for HTTP. Она была разработана в 2010 году.&nbsp;Учитывая занятость разработчиков браузеров реализацией поддержки HTML5,&nbsp;вряд ли PATCH получит широкое распространение в ближайшее время. RFC5789 вводит еще один HTTP-метод, а значит еще один REST-глагол, область применения которого пересекается с POST, PUT и частично DELETE. Структура PATCH конструкций значительно более сложна и громоздка по сравнению с остальными HTTP-методами.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">5. Моя любимая&nbsp;<b><a href="http://en.wikipedia.org/wiki/Same_origin_policy">SOP</a>-problem </b>и ее решение <span class="st">—</span> <b>JSONP</b>. Эта пара привлекла мое внимание исключительно тем, что делает бессмысленным само название "REST". Для несведущих поясню, что REST расшифровывается как Representational state transfer. Основная идея REST <span class="st">—</span> отделение представления данных от способа передачи, что теоретически должно позволить клиенту и серверу без дополнительных накладных расходов согласовывать способ представления данных и его использовать. На практике JSONP является единственным приемлемым решением проблемы SOP. И будет таковым до тех пор, пока все браузеры полностью не реализуют HTML5 Security. Ну и еще лет пять после этого события. JSONP фактически ограничивает способ представления данных только одним JSON.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">6. <b>Обработка ошибок</b>. Сторонникам REST нравится утверждать, что в HTTP уже встроен мощный механизм обработки ошибок <span class="st">—</span> status code. Да, да, статус-код <span class="st">—</span> вот она панацея. Однако, если присмотреться, какие именно статус-коды реально используются в web-приложениях?&nbsp;</div><blockquote><i>200, 301, 303, 304, 401, 403, 404, 405, 500</i></blockquote><div style="text-align: justify;">Кстати, почти все REST-фреймворки используют вместо 405 код 404.&nbsp;</div><div style="text-align: justify;">Для обработки прикладных ошибок, специфичных для бизнес-логики приложения, пригодны только два кода:&nbsp;</div><ul style="text-align: justify;"><li><i>412 Precondition Failed </i><span class="st">—</span> использование в production mode крайне не рекомендуется, лучше что-то вернуть и уведомить администратора</li><li><i>500 <span class="st">Internal Server Error&nbsp;</span></i><span class="st">— сигнал о том, что</span>&nbsp;что-то пошло не так.&nbsp;</li></ul><div style="text-align: justify;">Обучающие примеры, которые при вызове <i>PUT /product/51 </i>возвращают 404, в реальной жизни, как правило, не имеют смысла, поскольку клиентское приложение получает запись прежде, чем ее редактировать, а следовательно, уверено в ее наличии.</div><div style="text-align: justify;">Опять же, REST хорошо справляется с простейшим случаем, а для более-менее расширенного варианта приходится реализовывать собственный маппинг исключений в JSON и разбирать его на стороне клиента. Это пришлось бы делать и без REST.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Основная выгода применения REST-подхода, о которой говорят большинство REST-евангелистов <span class="st"></span><span class="st">— </span>полное использование возможностей HTTP. Простите, но мне не нужно полностью использовать его возможности, если это приносит мне больше проблем, чем пользы.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">По сути, популярность среди разработчиков завоевал не REST, а  фреймворки его реализующие, которые заодно решили массу распространенных  проблем:</div><ul style="text-align: justify;"><li>конвертации объектов серверного приложения в JSON/XML представление</li><li>разделение логики обработки запросов (на основе адресов и глаголов)</li><li>сокрытие деталей работы с HTTP <span class="st">—</span> упрощенный доступ к заголовкам и атрибутам запросов.</li></ul><div style="text-align: justify;">В качестве приемлемой альтернативы REST я бы привел реализацию <a href="http://devlicio.us/blogs/casey/archive/2009/02/12/ddd-command-query-separation-as-an-architectural-concept.aspx">Command Query Separation</a> подхода поверх HTTP. При этом можно легко использовать REST-фрейморки (Jersey, Jackson, JAX-B). Не накладывая на себя добровольно дополнительных REST-ограничений и оставаясь хозяином  положения <span class="st">—</span> хотите GET <span class="st">—</span> делайте его, хотите изменить данные на сервере <span class="st">—</span> нет ничего проще и все это без проблем. </div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">В качестве дополнительного подтверждения всех приведенных выше аргументов отмечу, что большинство RESTful API гигантов IT-индустрии (Amazon, Facebook, eBay, Yahoo, Youtube) на поверку являются реализацией Command Query Separation. Единственным у кого <a href="http://developers.facebook.com/docs/reference/rest/">хватило честности это признать стал Facebook</a>.&nbsp;</div>
</div>